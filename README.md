# springmvcdemo
用来测试spring mvc各种场景功能！
目前添加的demo有
## 已完成功能
 - json,xml自适应输出。通过ContentNegotiatingViewResolver相关配置解决的。
 - 通过@InitBinder实现自定义校验的逻辑。
 - 添加拦截器，实现所有拦截器和url匹配拦截器的逻辑
 - 统一异常处理逻辑和异常的状态码设置。
 - @MatrixVariable的实现和配置逻辑
 - 使用flashAtrribute 实现重定向的数据传递的逻辑
 - spring boot的静态资源处理（这个正常应该放在Nginx，这里有点多余）
 - 整合freemarker 视图解析
 - 添加mybatis-generator自动生成mapper的处理
 - 整合mybatis。
 - 添加事务支持
 - 用spring的data jpa实现缓存逻辑。用的是redis作为缓存结构处理。
    - 实现逻辑是定制key完成缓存的添加和删除
    - 定制是调用逻辑之前删除缓存还是之后删除缓存
    - 实现缓存，db的强一致性处理
 - 整合MongoDB，用于存储数据。
 - 添加时区转换的工具类，用于不同时区的时间转化
 - 添加自定义requestMapping的实现，用于处理自定义方法和关闭某些方法的需求
    - 关闭方法有两个实现，一个配置uri，然后注册的时候读取uri，发现配置的直接从配置里面删除。第二个是加注解，读取到注解信息，然后删除
    - 自定义方法的拦截，意思是通过注解,把requestMapping原本匹配的方法转化到另一个无关类上面去.实现逻辑的移植.
 - 多个候选bean的情况下,如果选择出合适bean的处理.
    - 如果其中有一个被@Primary注解修饰了,则获取到这个bean.
    - 如果存在多个被@Primary注解修饰了.则抛错
    - 如果需要在多个bean中进行排序处理,则可以使用@Priority注解.值越小,表示优先级越高.
    - @Primary注解和@Priority注解处理都优先于没有加这两个注解的bean实现.
    
    
 ## 待完成功能：
 - 操作限流
 - log写入消息kafka
 - 条件注解选择性实例化bean
 
 
 ## 特殊功能说明
    一、缓存
    用aop实现缓存的强一致性处理。
    因为我们一般情况下，在处理缓存和db双写的时候，先删缓存和先更新db都会存在脏数据的可能性。首先我们来分析下这两种情况的发生：
     1、先删缓存：先删缓存的情况下，在并发情况下，如果先删除缓存，再更新数据库，
        线程1：更新数据，删除缓存
        线程2：查询数据，发现缓存中没有，查询数据库
        线程2：将查询到的数据，放入换粗
        线程1：更新完数据库，返回
        结果导致缓存中一直存在的是脏数据。直到缓存过期。或者下一次更新
     2、先处理数据库，再删缓存
        线程1：更新数据库中的数据
        线程2：获取数据，发现缓存中有，直接命中
        线程1：删除缓存
        导致在线程2获取到的数据不是最新的数据而是脏数据。
      这两种都会导致脏数据的产生。只不过第二种时间更短，业务上倾向于第二种。但是如果需要强一致性的话，又怎么保证呢。
      这里的解决办法是在第二种方案的基础上添加一个中间态，也存在缓存中。
      在更新数据库的时候，将中间态的值设置进去。更新完成后删除。
      查询线程在获取数据的时候，发现缓存中没有，则先判断有没有存在中间态。存在则休眠10ms。用这种方式解决强一致性。一般第二种就够用了
    
    二、禁用api的逻辑实现
    之所以禁用不直接删除，是因为某些用户还得用。就是不同的部署实例上的暴露的api可能不一致。所以这里提供了这种方式来实现的。

    